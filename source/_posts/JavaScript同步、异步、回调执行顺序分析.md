---
title:  JavaScript同步、异步、回调执行顺序分析
date: 2018-3-6
tags: [JS] 
---



之所以写这篇文章，是因为在工作的时候遇到一个问题，一个异步函数，我必须要异步的返回结果作为后续的判断依据，也就是需要它按同步顺序执行。但是一般情况下，异步函数是无法确定什么时候会执行完。

为了让异步函数同步执行，做了很多尝试都没有成功，最后分析了同步、异步和回调的执行顺序，发现是这样的：

> 同步优先、异步靠边、回调垫底
>
> 用公式表达就是：同步 => 异步 => 回调

<!--more-->

### 同步和回调执行顺序

什么意思呢，我来举个常见的栗子，非常经典的题目：

```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}

console.log(i);
```

对于这道前端笔试题，输出的结果有两种可能：

- 第一种可能的答案：0 1 2 3 4 5 5
- 第二种可能的答案：5 5 5 5 5 5 5（后面每个5隔一秒输出）

究竟是哪一种？根据前面提到的执行顺序，你可以稍加思考看看。当然，第二种的结果肯定是对的，分析一下为什么是这个结果：

> 1）for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。（同步优先）
>
> 2）for循环里面有一个setTimeout回调，他是垫底的存在，只能最后执行。（回调垫底）

这个也是非常好理解，for循环先执行，但是不会给setTimeout传参（回调垫底），等for循环执行完，就会给setTimeout传参，而外部的console打印出5是因为for循环执行完成了。

 那么我们要如何能够输出0 1 2 3 4 5呢？目前我所知道的方法有两种，第一种是利用let的方法，第二种是利用闭包的方法。具体的就不分析了，这里主要说说调用顺序问题。

上面主要讲了同步和回调执行顺序的问题，接着我就举一个包含同步、异步、回调的例子。

### 同步、异步、回调

```javascript
let a = new Promise(
  function(resolve, reject) {
    console.log(1)
    setTimeout(() => console.log(2), 0)   // 回调垫底
    console.log(3)
    console.log(4)
    resolve(true)
  }
)
a.then(v => {   // then() 异步靠边
  console.log(8)
})
 
let b = new Promise(
  function() {
    console.log(5)
    setTimeout(() => console.log(6), 0)   // 回调垫底
  }
)

console.log(7)
```

在看正确结果之前，首先要明白Promise的异步含义：Promise是异步的，是指他的then()和catch()方法，Promise本身还是同步的，也就是说在 then() 和 catch() 内部，代码还是按照（同步 => 异步 => 回调）顺序执行 。

上个图看一下结果！

![74e2cb77e9f02f65f2ab0602d1aae321.png](https://i.loli.net/2019/03/06/5c7fb6a68e02f.png)

过程分析：

- 1）看同步代码：按照上面分析的同步优先，回调垫底，首先执行的就是a里面的的三个console.log()

```javascript
console.log(1)
setTimeout(() => console.log(2), 0) //回调垫底
console.log(3)
console.log(4)
```

- 2）Promise内部有4个console，第二个是一个setTimeout回调（回调垫底，所以暂时不输出）。所以这里先输出1，3，4，回调的方法丢到消息队列中排队等着。
- 3）接着执行resolve(true)，进入then()，then是异步，下面还有同步没执行完呢，所以then也去消息队列排队等候。（异步靠边）
- 4）b变量也是一个Promise，和a一样，同样是同步的，执行内部的同步代码，输出5，setTimeout是回调，去消息队列排队等候，这里输出5。
- 5）最下面同步输出7。
- 6）现在同步的代码执行完了，JavaScript就跑去消息队列呼叫异步的代码：异步，出来执行了。这里只有一个异步then，所以输出8。
- 7）此时，异步也over，轮到回调函数：回调，出来执行了。这里有2个回调在排队，他们的时间都设置为0，所以不受时间影响，只跟排队先后顺序有关。则先输出a里面的回调2，最后输出b里面的回调6。
- 8）最终输出结果就是：1、3、4、5、7、8、2、6。

到这里大概差不多了，关于执行顺序还是多去实践和理解，JavaScript博大精深，不是一句话就能概括出来的。最后再说一句，利用异步和回调的执行顺序，可以实现异步的先执行，但是对于回调频繁使用带来的后果，还需要慢慢研究。


> 现在ES6有别的方法来解决同步异步的问题。后续补充方法！

