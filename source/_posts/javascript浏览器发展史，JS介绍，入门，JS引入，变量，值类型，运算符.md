---
title: javascript浏览器发展史，JS介绍，入门，JS引入，变量，值类型，运算符
date: 2019-3-6
tags: [JS] 
---

前端不像是后端有那么多选择，像Python、PHP、JAVA、C#等等。学前端，JavaScript可以说是必学的一门语言。而在现在的21世纪，编程重要，还有另外一门技术同样很重要。那就是英语！**英语+互联网是最完美的组合**，如果再加上**金融**，那就是真的几乎可以上天了。当然，，我这里说的金融不是股票什么的，而是最低资金成本，金融也不是一般人能玩得起的，除非你有能力，有财力， 对金融也足够了解。

# JavaScript浏览器发展及入门

## 浏览器组成
    有两部分，一是shell，另外一部分是内核，当然，内核是最值钱的。

- **shell**：指的是我们能够看见的浏览器的标签、页面、设置、书签管理器、导航等等。凡是我们能看见的都可称之为shell。

- **内核**（大致分为三个模块）：
    内核就是用来处理我们的各种请求的代码，那些高难度的资源处理都是内核完成。
    - 渲染引擎（HTML、CSS等语法规则和渲染）
    - JS引擎
    - 其他模块

<!--more-->

**现时主要的四大排版引擎为**：

- Trident（应用于Internet Explorer）；
- Gecko（应用于Mozilla Firefox）；
- Blink（应用于Chrome ）；
- WebKit （应用于Apple Safari和早期版本的Google Chrome）比较火热。
浏览器几大内核问题，可 [参照这里](http://www.cnblogs.com/xiyangbaixue/archive/2014/10/22/4042548.html)

## JavaScript的两大特点

- 编译性 和 解释性

计算机在执行程序员编写的代码时，计算机认识这些代码吗？答案肯定是否定的，那么怎么让它读取并执行？那就需要转译。JavaScript代码转换为机械码的两种方式，编译性翻译和解释性翻译。这两种方式只是其翻译的方式不同，其本质是相同的。

### 1、编译性翻译

- **方式**：编译性翻译是通篇看完文件后再翻译，翻译完成后生成翻译完的文件，程序最终执行的是这个翻译完的文件。
  比如C-->.obj，JAVA-->.class。

- **优点**：快。
  就像读书一样，是通篇读完理解再写快还是看一句写一句快？当然是前者快，它节省了多次抬头低头的时间。

- **不足**：移植性不好，不跨平台。
  不跨平台是什么意思？比如在windows上生成的翻译文件，在Linux上不能执行，Linux系统不认识，那就得单独为Linux重新写一个。大多家用配置都是windows，但服务器用的是Linux、UNIX，因为它比较稳定。UNIX比较有故事 ，它是黑客和工程师共同开发的，所以黑客很难攻进去。（服务器其实就是电脑，只是它提供的接口不一样而已。）

- C、C++都是编译性语言

### 2、解释性语言

- **方式**：翻译一行执行一行，不生成文件。

- **优点**：跨平台。

- **缺点**：稍微慢一点。

- JavaScript、PHP、Python都是解释性语言

注意：**JAVA既不是编译性语言也不是解释性语言**，JAVA的翻译过程是:.java通过javac进行编译-->.class-->JVM(虚拟机)-->解释执行。JAVA原来是oracle语言。

## 线程

- **单线程**：同一时间只能干一件事
- **多线程**：同一时间可以干多件事。比如左手画圆右手画方，当然我是做不到的。

## 标准(ECMA)

每一门语言都有他的标准，JavaScript兼容于ECMA标准，因此也被称为ECMAScript，JavaScript到现在做了很大的改变，还推出了DOM和BOM。
关于ES6标准，可以[参考这里](http://es6.ruanyifeng.com/)

## JavaScript三大部分

- **ECMAScript**：这是JavaScript原始部分，能够进行加减乘除。
- **DOM**：操作文档（html、css）
- **BOM**   ：操作浏览器对象。

## JavaScript执行队列

单线程的执行有一个专业名词：**轮转时间片**。

下面举个栗子：
比如现在同时执行两个任务，task1和task2。它会把两个任务切成无数片段，以微秒或毫秒为单位，吧这些片段排成队列，但是谁排前面谁排后面完全随机，谁排第一页不一定，这就叫**争抢时间片**，完全看概率。排完后一个片段一个片段地往JavaScript引擎送，JavaScript一2一个时间片为基准单位来执行这个时间片段，然后把task1和task2按时间片段来执行。大概类似下图：

![QQ截图20190306195223.jpg](https://i.loli.net/2019/03/06/5c7fb486cede4.jpg)


***
***

面试常被问到的问题
**1、主流浏览器及内核**、

- IE ---- trident
- chrome ---- 以前是webkit，2014年新出blink
- firefox ---- Gecko
- opera ---- presto
- safari ---- webkit

**2、面试最后面试官通常会问：你还有什么问题想问我？**

问这个问题的原因是什么呢，面试官希望通过这个问题看出你的学习能力和学习现状，包括探究方向

## 开始学习JavaScript

### 1、引用js。

- 这个也就内部JS及外部JS文件引用，引用方式都可以百度到，我只强调一点，对于type属性 ，你可以不写，但是不能写错。

- 为符合web结构(html)、样式(css)、行为(js)相分离的标准，通常采用外部引入。

- 相分离，主要是为了在需要看得时候更加清晰，改的时候更加方便，移植性也会比较好。

### 2、JS基本语法

- 变量
    - 变量声明
        - 声明、赋值分解。也就是说声明和赋值是可以分开 进行的，你可以先声明变量，之后再赋值。
        - 单一var声明变量
    - 命名规则
        - 变量名必须以英文字母、_、$开头
        - 可以包括英文字母、_、$、数字
        - 不可用关键字和保留字作变量名。[JS关键字和保留字汇总](http://www.itxueyuan.org/view/6627.html)

```js
    var a = 10,
        b = 20;
        c = 30;
        d;

    document.write(a,b,c,d);
    //102030Undefined
```

## 3、基本类型

- 值类型——数据类型
    - 不可变的原始值(stack栈数据)
        - Number、String、Boolean、Undefined(声明变量未赋值时就是undefined)、Null
    - 引用值(heap堆数据)
        - array、object、function
    - 引用这和原始值唯一的不同就是赋值形式的不同。

1、语言分为两大类，一类是静态语言，一类是动态语言。动态语言基本是解释性语言，解释性语言基本是脚本语言。
2、解释性语言特点是：声明变量的关键字只有一个，比如JS声明变量，只有var。不像java，有int、float、char、string。
3、为什么只需要var声明变量，而不需要声明变量类型？因为解释性语言是解释一行执行一行，不会通篇翻译。
4、如果你还不知道什么是解释性语言，[请看这里](https://ouchunrun.github.io/2017/11/15/2017-11-15-%E6%B8%A1%E4%B8%80%E6%95%99%E8%82%B2%E4%B9%8BJavaScript1/)

**关于JavaScript**

- JavaScript是动态语言，javascript的数字类型天生就是浮点型。
- JavaScript是由值决定类型，其他的比如java，是由类型决定值，比如你定义了一个int a;你就必须给a赋一个int类型的值。
- 原始值是存在栈里，栈是first-in-last-out。站内存之间爱你的赋值都是拷贝。

```javascript
    var a = 10;
    var b = a;  //是对a值得一个拷贝
    a = 20;  //重新赋值时，并不止在原基础上改变的，而是申请了一个内存空间，再把a指向这个心的地址空间
    document.write(b);
    //10
```

- 引用值存在heap堆里，堆是先进先出。引用值得栈内存的是堆内存的地址，真是的数据时存放在堆里的。而引用值赋值的时候只是拷贝地址，不拷贝原始数据。

```javascript
    var arr = [1];
    var arr1 = arr;
    arr.push(2);
    document.write(arr1);
    //1,2
    //引用值arr1跟着变化了 ，因为它指向的本身就是arr的地址。

```

注意：
```javascript
    var arr = [1];
    var arr1 = arr;
    arr = [1,3];   //这里新申请了一个内存空间，不会覆盖原有的地址空间，也就是说原来的[1,2]地址还在，且arr1指向了它。
    document.write(arr1);
    //1,2
```

## 4、JS运算符

`但凡是运算，就要求结果。`

### 运算操作符
    - +
        - 数学运算、字符串连接
        - **任何数据类型加字符串都等于字符串**
    - "-"、"*"、"/"、"%"、"="、"()"
    - 优先级"="最弱，"()"最强
    - "--"、"++"、"+="、"-="、"%="、"*="等

```javascript
    //示例：
    var a = a+1;   //a1
    var a = 1 + 1 + a;   //11a
    var a = a + 1 + 1;    //a11

```

**除号"/"的一些注意事项：**

- 1/0 结果是Infinity(Infinity是Number型)
- 0/0 结果是 Nan(not a number)。但是Num也是number的一员
- -1/0 结果是-Infinity
- 记住运算顺序：先括号， 再乘除，最后加减


先看一个练习题，很简单，给定两个数a、b，交换两个数。

常见方法，引入新变量
```javascript
    var a = 123;
    var b = 234;
    var c = a;
    a = b;
    b= c;
```
上面的方法可以实现，但是可以用另外一个更上一层的方法。
```javascript
    var a = 123;
    var b = 234;
    a = a + b;
    b = a - b;
    a = a - b;
    //这样写的好处是，如果a、b变化了，仍然使用。
```

### 比较运算符

- `>、<、==、<=、>=、！=`;
- 比较结果为Boolean值。

任何东西都能比较，只是规则不同，例如字符串之间比较的是ASC码顺序。

- ASC I码是七位二进制数（0~128）。
- ASC II码是八位二进制数（1~255）。

### 逻辑运算符

- $$、||、！。
- 运算结果为真实值。

### 被认定为false的值。

- undefined、null、NaN、""、0、false。

- 特殊原则：
```javascript
    NaN = NaN;     //false
```
**也就是非数NaN不等于任何东西，包括自己。**

下面重点说一下逻辑运算符：

先打破一下的传统的观念：
```javascript
    var a = 1&&2;
    document.write(a);
    //猜一下结果是多少呢？
    //结果是2，是不是超出意外。
```

#### `&&`运算

- `&&`运算符，有两个表达式的情况，先看第一个表达式转换成布尔值的结果，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只要看到第二个表达式，就可以返回该表达式的值；如果第一个表达式转换为布尔值为false，直接返回第一个表达式的值。
- 如果有两个以上表达式的话，只要为真就往后走，为假时返回假的位置的表达式的值。

**实际应用**
```javascript
    //实际应用
    var data = "这里是从后台传过来的数据";
    data && fn(data);
    //这里的意思是说，当data有意义时，才执行fn(data)调用，否则会造成系统的瘫痪。
```

#### `||`运算

遇到false就一直走，直到遇见ture或最后一个表达式则返回表达式的值。

```javascript
    var num = 0 || false || 1;
    document.write(num);
    //false
```

写兼容。注意，在IE浏览器里面，window.event里面有值，e是undefined；在非IE浏览器里面，window.event里面为undefined，e是有值得。

```javascript
    div.onclick = function(e){
        var event = e || window.event;
    }
```

#### `!`运算

```javascript
    var a = !123;    //先把a变成布尔值再取反。

    var b = !!null;
    var c = !!"";
    var d = !!NaN;
    //b、c、d都返回false
    //这里现将后面的值变成布尔值再取反。
```












